# Created by: Deserno, M. et. al., 2023 for https://www.nature.com/articles/s41598-023-38213-7
# Experimental code to visualize tracking results.

import colorsys
import os
import pickle
import random

import cv2
import numpy as np
import pycocotools.mask as mask
from alive_progress import alive_bar


def generate_colors(num_colors, ret_float=False) -> list:
    # https://stackoverflow.com/a/9701141
    # with modifications
    colors = []
    for i in np.arange(0.0, 360.0, 360.0 / num_colors):
        hue = i / 360.0
        lightness = (50 + np.random.rand() * 10) / 100.0
        saturation = (90 + np.random.rand() * 10) / 100.0

        rgb = np.array(colorsys.hls_to_rgb(hue, lightness, saturation))

        # return float or 8-bit
        if not ret_float:
            # convert 0 - 1 to 0 - 255 RGB values
            colors.append(np.around(255 * rgb))
        else:
            colors.append(rgb)
    return colors


def apply_mask(image, mask, color, alpha=0.5):
    # from https://github.com/VisualComputingInstitute/mots_tools/blob/master/mots_vis/visualize_mots.py
    # orig. from https://github.com/matterport/Mask_RCNN/blob/master/mrcnn/visualize.py
    """
    Apply the given mask to the image.
    """
    for c in range(3):
        image[:, :, c] = np.where(
            mask == 1,
            image[:, :, c] * (1 - alpha) + alpha * color[c],
            image[:, :, c],
        )
    return image


def find_imgs(img_path: str, file_ending: str) -> list[str]:
    # find all imgs in given folder
    imgs: list[str] = []

    for file in os.listdir(img_path):
        if file.endswith(file_ending):
            imgs.append(file)

    # sort images accordingly
    imgs = sorted(imgs, key=lambda img: int(img.split(".")[0]))

    return imgs


def extract_predictions(score_thres: float, data_path: str):
    # extract predictions from .pkl files generated by MMDetection
    # open result file
    data_pkl = open(data_path, "rb")
    data = pickle.load(data_pkl)

    det_scores_per_image: dict[int, list[np.float32]] = {}
    det_masks_per_image: list[list[np.ndarray]] = []
    det_boxes_per_image: list[list[np.ndarray]] = []

    # iterate over detections for all images
    for img_i, img_data in enumerate(data):
        # index 1 of tuple -> t[0]: BBox + Score, t[1]: Size + RLE; 0 to because of surrounding list
        detection_scores = img_data[0][0]
        detection_masks = img_data[1][0]

        # store masks and score per image
        det_scores: list[np.float32] = []
        det_masks: list[np.ndarray] = []
        det_boxes: list[np.ndarray] = []
        for det_idx in range(len(detection_masks)):
            det_score: np.ndarray = detection_scores[det_idx]

            if det_score[4] <= score_thres:
                continue

            det_scores.append(det_score[4])
            det_boxes.append(det_score[:4])

            roi_dict = detection_masks[det_idx]
            dec_mask = mask.decode(roi_dict)
            det_masks.append(dec_mask)

        det_scores_per_image[img_i] = det_scores
        det_masks_per_image.append(det_masks)
        det_boxes_per_image.append(det_boxes)
    data_pkl.close()

    return det_scores_per_image, det_masks_per_image, det_boxes_per_image


if __name__ == "__main__":
    score_thres: float = 0.5
    imgs_path: str = "frames/"
    pred_path: str = "pred_res.pkl"
    tracking_path: str = "tracking.pkl"
    img_out_path: str = "imgs_out/"
    video_out_path: str = "video_out/"

    tracking_result_imgs = []

    tracking_pkl = open(tracking_path, "rb")
    tracking = pickle.load(tracking_pkl)
    tracking_pkl.close()

    img_names = find_imgs(imgs_path, ".png")
    (
        det_scores_per_image,
        det_masks_per_image,
        det_boxes_per_image,
    ) = extract_predictions(score_thres, pred_path)

    colors = generate_colors(999)
    random.shuffle(colors)

    prev_centers = {}
    img_keys = list(det_scores_per_image.keys())
    img_keys = sorted(img_keys, key=lambda k: int(k))
    untracked_worms_counter = 0
    with alive_bar(len(img_keys)) as bar:
        for img_id in img_keys:
            if img_id >= len(img_names):
                continue
            img_name = img_names[img_id]

            scores = det_scores_per_image[img_id]
            masks = det_masks_per_image[img_id]
            boxes = det_boxes_per_image[img_id]

            img = cv2.imread(
                os.path.join(imgs_path, img_name), cv2.IMREAD_COLOR
            )

            for pred_id in range(len(scores)):
                if (
                    scores[pred_id] < score_thres
                ):  # reject low confidence detections
                    continue

                # search tracking ID
                global_track_id = -1
                for tracked_worm in tracking.items():
                    if tracked_worm[1][img_id] == pred_id:  # access values
                        global_track_id = tracked_worm[
                            0
                        ]  # get global tracking id
                        break

                if global_track_id == -1:
                    print(
                        f"!!! No Tracking ID found for det_idx: {pred_id} !!!"
                    )
                    global_track_id = 1000 + untracked_worms_counter
                    untracked_worms_counter += 1

                mask = masks[pred_id]
                box = boxes[pred_id]

                if global_track_id >= 1000:
                    color = (255, 255, 255)
                else:
                    color = colors[global_track_id]

                img = apply_mask(img, mask, color, alpha=0.5)

                # find center of worm
                worm_center = (
                    int(box[0] + (box[2] - box[0]) / 2),
                    int(box[1] + (box[3] - box[1]) / 2),
                )

                if global_track_id not in prev_centers.keys():
                    # prev_centers[global_track_id] = [-1] * img_id  # add -1 for untracked frames
                    prev_centers[global_track_id] = []

                prev_centers[global_track_id].append(worm_center)

                # draw path if possible
                if global_track_id in prev_centers.keys():
                    prev_worm_center = prev_centers[global_track_id]

                    for point1, point2 in zip(
                        prev_worm_center, prev_worm_center[1:]
                    ):
                        img = cv2.line(img, point1, point2, color, 2)

                img = cv2.circle(
                    img, worm_center, radius=1, color=(0, 0, 0), thickness=-1
                )  # mark current position on image

            cv2.imwrite(os.path.join(img_out_path, img_name), img)
            tracking_result_imgs.append(img)
            bar()  # update progress bar

    # create video out of images
    video = cv2.VideoWriter(
        os.path.join(video_out_path, "tracking.mov"),
        cv2.VideoWriter_fourcc("m", "p", "4", "v"),
        5,
        (912, 736),
    )
    for tr_img in tracking_result_imgs:
        video.write(tr_img)

    cv2.destroyAllWindows()
    video.release()
    print("Done.")
